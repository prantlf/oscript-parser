!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).walker={})}(this,(function(t){"use strict";function e(t,e){return Object.assign(e||i,t)}function n(t){return"string"==typeof t?{post:({type:e})=>e===t}:"function"==typeof t?{post:t}:t||{post:()=>!0}}class o{constructor(t){this.node=t}}class s{constructor(t,e){this.node=t,this.parent=e}}function r(){}const i={Program:(t,e,n)=>{n(t.body,t,e)},PackageDeclaration:(t,e,n)=>{n(t.name,t,e),n(t.object,t,e)},ObjectDeclaration:(t,e,n)=>{n(t.id,t,e),t.superObject&&n(t.superObject,t,e);for(const o of t.body)n(o,t,e)},FeatureDeclaration:(t,e,n)=>{n(t.id,t,e),t.init&&n(t.init,t,e)},ObjectName:(t,e,n)=>{for(const o of t.name)n(o,t,e)},ScriptSource:(t,e,n)=>{for(const o of t.body)n(o,t,e)},DumpSource:(t,e,n)=>{n(t.id,t,e),n(t.parent,t,e);for(const o of t.assignments)n(o,t,e);for(const o of t.assignments)n(o,t,e);for(const o of t.scripts)n(o,t,e)}};i.FeatureAddition=i.LabelStatement=(t,e,n)=>{n(t.id,t,e)},i.FeatureInitialization=(t,e,n)=>{n(t.id,t,e),n(t.value,t,e)},i.ScriptDeclaration=(t,e,n)=>{n(t.id,t,e);for(const o of t.body)n(o,t,e)},i.FunctionDeclaration=(t,e,n)=>{n(t.id,t,e);for(const o of t.params)n(o,t,e);for(const o of t.body)n(o,t,e)},i.Parameter=(t,e,n)=>{n(t.id,t,e),t.init&&n(t.init,t,e)},i.IfStatement=(t,e,n)=>{n(t.test,t,e);for(const o of t.consequent)n(o,t,e);for(const o of t.otherClauses)n(o,t,e);for(const o of t.alternate)n(o,t,e)},i.ElseIfClause=(t,e,n)=>{n(t.test,t,e);for(const o of t.consequent)n(o,t,e)},i.SwitchStatement=(t,e,n)=>{n(t.discriminant,t,e);for(const o of t.cases)n(o,t,e)},i.SwitchCase=(t,e,n)=>{for(const o of t.tests)n(o,t,e);for(const o of t.consequent)n(o,t,e)},i.WhileStatement=i.RepeatStatement=(t,e,n)=>{n(t.test,t,e);for(const o of t.body)n(o,t,e)},i.ForStatement=(t,e,n)=>{t.init&&n(t.test,t,e),t.test&&n(t.test,t,e),t.update&&n(t.update,t,e);for(const o of t.body)n(o,t,e)},i.ForEachStatement=(t,e,n)=>{n(t.left,t,e),n(t.right,t,e);for(const o of t.body)n(o,t,e)},i.StructuredForStatement=(t,e,n)=>{n(t.variable,t,e),n(t.start,t,e),n(t.end,t,e),t.step&&n(t.step,t,e);for(const o of t.body)n(o,t,e)},i.BreakStatement=i.ContinueStatement=i.EmptyStatement=r,i.BreakIfStatement=i.ContinueIfStatement=(t,e,n)=>{n(t.test,t,e)},i.GotoStatement=(t,e,n)=>{n(t.label,t,e)},i.ReturnStatement=(t,e,n)=>{t.argument&&n(t.argument,t,e)},i.VariableDeclaration=(t,e,n)=>{for(const o of t.declarations)n(o,t,e)},i.VariableDeclarator=(t,e,n)=>{n(t.id,t,e),t.init&&n(t.init,t,e)},i.ConditionalExpression=(t,e,n)=>{n(t.test,t,e);for(const o of t.consequent)n(o,t,e);for(const o of t.alternate)n(o,t,e)},i.BinaryExpression=(t,e,n)=>{n(t.left,t,e),n(t.right,t,e)},i.UnaryExpression=(t,e,n)=>{n(t.argument,t,e)},i.MemberExpression=(t,e,n)=>{n(t.object,t,e),n(t.property,t,e)},i.SliceExpression=(t,e,n)=>{n(t.object,t,e),n(t.start,t,e),n(t.end,t,e)},i.IndexExpression=(t,e,n)=>{n(t.object,t,e),n(t.index,t,e)},i.CallExpression=(t,e,n)=>{n(t.callee,t,e);for(const o of t.arguments)n(o,t,e)},i.ThisExpression=i.SuperExpression=r,i.AssocExpression=(t,e,n)=>{for(const o of t.properties)n(o,t,e)},i.Property=(t,e,n)=>{n(t.key,t,e),n(t.value,t,e)},i.ListExpression=(t,e,n)=>{for(const o of t.elements)n(o,t,e)},i.ListComprehension=(t,e,n)=>{n(t.expression,t,e),n(t.left,t,e),n(t.right,t,e),t.test&&n(t.test,t,e)},i.AtExpression=i.ParenthesisExpression=(t,e,n)=>{n(t.expression,t,e)},i.XlateExpression=(t,e,n)=>{n(t.ospace,t,e),n(t.string,t,e)},i.Identifier=i.LegacyAlias=i.Literal=r,t.ancestor=function(t,e,n,o){const s=[];n||(n=i),function t(o,r,i){const{type:c}=o,a=o!==s[s.length-1];a&&s.push(o);const f=e[c];let p,u;f&&({pre:p,post:u}=f);if(p){if(p(o,i,s))return void(a&&s.pop())}n[c](o,i,t),u&&u(o,i,s);a&&s.pop()}(t,0,o)},t.base=i,t.findNodeAround=function(t,e,o,r,c){const{line:a,column:f}=e,{pre:p,post:u}=n(o);r||(r=i);try{!function t(e,n,o){const{type:i,loc:c}=e,{start:l,end:d}=c;if(l.line>a||d.line<a||l.line===a&&l.line===d.line&&(l.column>f||d.column<f))return;if(p&&p(e,o,n))return;if(r[i](e,o,t),u(e,o,n))throw new s(e,n)}(t,null,c)}catch(t){if(t instanceof s)return{node:t.node,state:c,parent:t.parent};throw t}},t.findNodeAroundWithAncestors=function(t,e,s,r,c){const a=[],{line:f,column:p}=e,{pre:u,post:l}=n(s);r||(r=i);try{!function t(e,n,s){const{type:i,loc:c}=e,{start:d,end:m}=c;if(d.line>f||m.line<f||d.line===f&&d.line===m.line&&(d.column>p||m.column<p))return;const y=e!==a[a.length-1];y&&a.push(e);if(u&&u(e,s,a))return;if(r[i](e,s,t),l(e,s,a))throw new o(e);y&&a.pop()}(t,0,c)}catch(t){if(t instanceof o)return{node:t.node,state:c,ancestors:a};throw t}},t.full=function(t,e,n,o){const{pre:s,post:r}=e;n||(n=i),function t(e,o,i){const{type:c}=e;if(s&&s(e,i,o))return;n[c](e,i,t),r&&r(e,i,o)}(t,null,o)},t.fullAncestor=function(t,e,n,o){const{pre:s,post:r}=e,c=[];n||(n=i),function t(e,o,i){const{type:a}=e,f=e!==c[c.length-1];f&&c.push(e);if(s){if(s(e,i,c))return void(f&&c.pop())}n[a](e,i,t),r&&r(e,i,c);f&&c.pop()}(t,0,o)},t.make=e,t.recursive=function(t,n,o,s){const r=n?e(n,o):o;!function t(e,n,o){r[e.type](e,o,t)}(t,0,s)},t.simple=function(t,e,n,o){n||(n=i),function t(o,s,r){const{type:i}=o,c=e[i];let a,f;c&&({pre:a,post:f}=c);if(a&&a(o,r,s))return;n[i](o,r,t),f&&f(o,r,s)}(t,null,o)},Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.min.js.map
