{"version":3,"file":"index.umd.min.js","sources":["../index.js"],"sourcesContent":["// AST walker module for OScript AST\n\n// A simple walk is one where you simply specify callbacks to be\n// called on specific nodes. The last two arguments are optional. A\n// simple use would be:\n//\n//     walk.simple(myTree, {\n//       Expression: {\n//         pre: node => { ... }\n//       }\n//     })\n//\n// to do something with all expressions. All OScript AST node types\n// can be used to identify node types.\n//\n// Callbacks are specified by an object with pre and post properties,\n// which point to functions accepting a node. The pre-callback will be\n// called before children of the node will be visited and the post-callback\n// will be called after visiting the node children. If the pre-callback\n// returns true, children of the node will not be visited and the walking\n// will continue with the next sibling.\n//\n// The baseVisitor argument can be used to pass a custom (recursive)\n// walker, and state can be used to give this walked an initial\n// state.\n//\n// The state argument can be used to give this walk an initial state.\n\nexport function simple (node, visitors, baseVisitor, state) {\n  if (!baseVisitor) baseVisitor = base\n  walk(node, null, state)\n\n  function walk (node, parent, state) {\n    const { type } = node\n    const callbacks = visitors[type]\n    let pre, post\n    if (callbacks) ({ pre, post } = callbacks)\n    if (pre && pre(node, state, parent)) return\n    baseVisitor[type](node, state, walk)\n    if (post) post(node, state, parent)\n  }\n}\n\n// An ancestor walk keeps an array of ancestor nodes (including the\n// current node) and passes them to the callbacks as third parameter.\n\nexport function ancestor (node, visitors, baseVisitor, state) {\n  const ancestors = []\n  if (!baseVisitor) baseVisitor = base\n  walk(node, null, state)\n\n  function walk (node, parent, state) {\n    const { type } = node\n    const isNew = node !== ancestors[ancestors.length - 1]\n    if (isNew) ancestors.push(node)\n    const callbacks = visitors[type]\n    let pre, post\n    if (callbacks) ({ pre, post } = callbacks)\n    if (pre) {\n      const result = pre(node, state, ancestors)\n      if (result) {\n        if (isNew) ancestors.pop()\n        return\n      }\n    }\n    baseVisitor[type](node, state, walk)\n    if (post) post(node, state, ancestors)\n    if (isNew) ancestors.pop()\n  }\n}\n\n// A full walk triggers the callbacks on each node\n\nexport function full (node, callbacks, baseVisitor, state) {\n  const { pre, post } = callbacks\n  if (!baseVisitor) baseVisitor = base\n  walk(node, null, state)\n\n  function walk (node, parent, state) {\n    const { type } = node\n    if (pre && pre(node, state, parent)) return\n    baseVisitor[type](node, state, walk)\n    if (post) post(node, state, parent)\n  }\n}\n\n// An fullAncestor walk is like an ancestor walk, but triggers\n// the callbacks on each node\n\nexport function fullAncestor (node, callbacks, baseVisitor, state) {\n  const { pre, post } = callbacks\n  const ancestors = []\n  if (!baseVisitor) baseVisitor = base\n  walk(node, null, state)\n\n  function walk (node, parent, state) {\n    const { type } = node\n    const isNew = node !== ancestors[ancestors.length - 1]\n    if (isNew) ancestors.push(node)\n    if (pre) {\n      const result = pre(node, state, ancestors)\n      if (result) {\n        if (isNew) ancestors.pop()\n        return\n      }\n    }\n    baseVisitor[type](node, state, walk)\n    if (post) post(node, state, ancestors)\n    if (isNew) ancestors.pop()\n  }\n}\n\n// A recursive walk is one where your functions override the default\n// walkers. They can modify and replace the state parameter that's\n// threaded through the walk, and can opt how and whether to walk\n// their child nodes (by calling their third argument on these\n// nodes).\n\nexport function recursive (node, functions, baseVisitor, state) {\n  const visitor = functions ? make(functions, baseVisitor) : baseVisitor\n  walk(node, null, state)\n\n  function walk (node, parent, state) {\n    visitor[node.type](node, state, walk)\n  }\n}\n\n// Used to create a custom walker. Will fill in all missing node\n// type properties with the defaults.\n\nexport function make (functions, baseVisitor) {\n  return Object.assign(baseVisitor || base, functions)\n}\n\n// Finds the innermost node that contains the given position and passes the\n// given test. Returns a { node, state } object, or  undefined when it does\n// not find a matching node.\n\nexport function findNodeAround (node, position, test, baseVisitor, state) {\n  const { line, column } = position\n  const { pre, post } = makeFindTest(test)\n  if (!baseVisitor) baseVisitor = base\n  try {\n    walk(node, null, state)\n  } catch (error) {\n    if (error instanceof FoundWithParent) return { node: error.node, state, parent: error.parent }\n    throw error\n  }\n\n  function walk (node, parent, state) {\n    const { type, loc } = node\n    const { start, end } = loc\n    if (start.line > line || end.line < line ||\n        (start.line  === line && start.line === end.line &&\n        (start.column > column || end.column < column))) return\n    if (pre && pre(node, state, parent)) return\n    baseVisitor[type](node, state, walk)\n    if (post(node, state, parent)) throw new FoundWithParent(node, parent)\n  }\n}\n\n// Finds the innermost node that contains the given position and passes the\n// given test. Keeps an array of ancestor nodes (including the current node),\n// passes them to the test callbacks as a third parameter and includes them\n// in the returned object.\n\nexport function findNodeAroundWithAncestors (node, position, test, baseVisitor, state) {\n  const ancestors = []\n  const { line, column } = position\n  const { pre, post } = makeFindTest(test)\n  if (!baseVisitor) baseVisitor = base\n  try {\n    walk(node, null, state)\n  } catch (error) {\n    if (error instanceof Found) return { node: error.node, state, ancestors }\n    throw error\n  }\n\n  function walk (node, parent, state) {\n    const { type, loc } = node\n    const { start, end } = loc\n    if (start.line > line || end.line < line ||\n        (start.line  === line && start.line === end.line &&\n        (start.column > column || end.column < column))) return\n    const isNew = node !== ancestors[ancestors.length - 1]\n    if (isNew) ancestors.push(node)\n    if (pre && pre(node, state, ancestors)) return\n    baseVisitor[type](node, state, walk)\n    if (post(node, state, ancestors)) throw new Found(node)\n    if (isNew) ancestors.pop()\n  }\n}\n\nfunction makeFindTest (test) {\n  if (typeof test === 'string') return { post: ({ type }) => type === test }\n  else if (typeof test === 'function') return { post: test }\n  else if (!test) return { post: () => true }\n  else return test\n}\n\nclass Found {\n  constructor (node) { this.node = node }\n}\n\nclass FoundWithParent {\n  constructor (node, parent) { this.node = node; this.parent = parent }\n}\n\n// ---------- Node walkers.\n\nfunction ignore () {}\n\nexport const base = {}\n\nbase.Program = (node, state, walk) => {\n  walk(node.body, node, state)\n}\n\n// ---------- Package\n\nbase.PackageDeclaration = (node, state, walk) => {\n  walk(node.name, node, state)\n  walk(node.object, node, state)\n}\n\nbase.ObjectDeclaration = (node, state, walk) => {\n  walk(node.id, node, state)\n  if (node.superObject) walk(node.superObject, node, state)\n  for (const declaration of node.body) walk(declaration, node, state)\n}\n\nbase.FeatureDeclaration = (node, state, walk) => {\n  walk(node.id, node, state)\n  if (node.init) walk(node.init, node, state)\n}\n\nbase.ObjectName = (node, state, walk) => {\n  for (const identifier of node.name) walk(identifier, node, state)\n}\n\n// ---------- Script\n\nbase.ScriptSource = (node, state, walk) => {\n  for (const statement of node.body) walk(statement, node, state)\n}\n\n// ---------- Dump\n\nbase.DumpSource = (node, state, walk) => {\n  walk(node.id, node, state)\n  walk(node.parent, node, state)\n  for (const feature of node.assignments) walk(feature, node, state)\n  for (const assignment of node.assignments) walk(assignment, node, state)\n  for (const script of node.scripts) walk(script, node, state)\n}\n\nbase.FeatureAddition = base.LabelStatement = (node, state, walk) => {\n  walk(node.id, node, state)\n}\n\nbase.FeatureInitialization = (node, state, walk) => {\n  walk(node.id, node, state)\n  walk(node.value, node, state)\n}\n\n// ---------- Scopes\n\nbase.ScriptDeclaration = (node, state, walk) => {\n  walk(node.id, node, state)\n  for (const part of node.body) walk(part, node, state)\n}\n\nbase.FunctionDeclaration = (node, state, walk) => {\n  walk(node.id, node, state)\n  for (const param of node.params) walk(param, node, state)\n  for (const statement of node.body) walk(statement, node, state)\n}\n\nbase.Parameter = (node, state, walk) => {\n  walk(node.id, node, state)\n  if (node.init) walk(node.init, node, state)\n}\n\n// ---------- Statements\n\nbase.IfStatement = (node, state, walk) => {\n  walk(node.test, node, state)\n  for (const statement of node.consequent) walk(statement, node, state)\n  for (const statement of node.otherClauses) walk(statement, node, state)\n  for (const statement of node.alternate) walk(statement, node, state)\n}\n\nbase.ElseIfClause = (node, state, walk) => {\n  walk(node.test, node, state)\n  for (const statement of node.consequent) walk(statement, node, state)\n}\n\nbase.SwitchStatement = (node, state, walk) => {\n  walk(node.discriminant, node, state)\n  for (const switchCase of node.cases) walk(switchCase, node, state)\n}\n\nbase.SwitchCase = (node, state, walk) => {\n  for (const test of node.tests) walk(test, node, state)\n  for (const switchCase of node.consequent) walk(switchCase, node, state)\n}\n\nbase.WhileStatement = base.RepeatStatement = (node, state, walk) => {\n  walk(node.test, node, state)\n  for (const statement of node.body) walk(statement, node, state)\n}\n\nbase.ForStatement = (node, state, walk) => {\n  if (node.init) walk(node.test, node, state)\n  if (node.test) walk(node.test, node, state)\n  if (node.update) walk(node.update, node, state)\n  for (const statement of node.body) walk(statement, node, state)\n}\n\nbase.ForEachStatement = (node, state, walk) => {\n  walk(node.left, node, state)\n  walk(node.right, node, state)\n  for (const statement of node.body) walk(statement, node, state)\n}\n\nbase.StructuredForStatement = (node, state, walk) => {\n  walk(node.variable, node, state)\n  walk(node.start, node, state)\n  walk(node.end, node, state)\n  if (node.step) walk(node.step, node, state)\n  for (const statement of node.body) walk(statement, node, state)\n}\n\nbase.BreakStatement = base.ContinueStatement = base.EmptyStatement = ignore\n\nbase.BreakIfStatement = base.ContinueIfStatement = (node, state, walk) => {\n  walk(node.test, node, state)\n}\n\nbase.GotoStatement = (node, state, walk) => {\n  walk(node.label, node, state)\n}\n\nbase.ReturnStatement = (node, state, walk) => {\n  if (node.argument) walk(node.argument, node, state)\n}\n\nbase.VariableDeclaration = (node, state, walk) => {\n  for (const declaration of node.declarations) walk(declaration, node, state)\n}\n\nbase.VariableDeclarator = (node, state, walk) => {\n  walk(node.id, node, state)\n  if (node.init) walk(node.init, node, state)\n}\n\n// ---------- Expressions\n\nbase.ConditionalExpression = (node, state, walk) => {\n  walk(node.test, node, state)\n  for (const statement of node.consequent) walk(statement, node, state)\n  for (const statement of node.alternate) walk(statement, node, state)\n}\n\nbase.BinaryExpression = (node, state, walk) => {\n  walk(node.left, node, state)\n  walk(node.right, node, state)\n}\n\nbase.UnaryExpression = (node, state, walk) => {\n  walk(node.argument, node, state)\n}\n\nbase.MemberExpression = (node, state, walk) => {\n  walk(node.object, node, state)\n  walk(node.property, node, state)\n}\n\nbase.SliceExpression = (node, state, walk) => {\n  walk(node.object, node, state)\n  walk(node.start, node, state)\n  walk(node.end, node, state)\n}\n\nbase.IndexExpression = (node, state, walk) => {\n  walk(node.object, node, state)\n  walk(node.index, node, state)\n}\n\nbase.CallExpression = (node, state, walk) => {\n  walk(node.callee, node, state)\n  for (const argument of node.arguments) walk(argument, node, state)\n}\n\nbase.ThisExpression = base.SuperExpression = ignore\n\nbase.AssocExpression = (node, state, walk) => {\n  for (const property of node.properties) walk(property, node, state)\n}\n\nbase.Property = (node, state, walk) => {\n  walk(node.key, node, state)\n  walk(node.value, node, state)\n}\n\nbase.ListExpression = (node, state, walk) => {\n  for (const element of node.elements) walk(element, node, state)\n}\n\nbase.ListComprehension = (node, state, walk) => {\n  walk(node.expression, node, state)\n  walk(node.left, node, state)\n  walk(node.right, node, state)\n  if (node.test) walk(node.test, node, state)\n}\n\nbase.AtExpression = base.ParenthesisExpression = (node, state, walk) => {\n  walk(node.expression, node, state)\n}\n\nbase.XlateExpression = (node, state, walk) => {\n  walk(node.ospace, node, state)\n  walk(node.string, node, state)\n}\n\n// ---------- Identifiers and Literals\n\nbase.Identifier = base.LegacyAlias = base.Literal = ignore\n"],"names":["make","functions","baseVisitor","Object","assign","base","makeFindTest","test","post","type","Found","[object Object]","node","this","FoundWithParent","parent","ignore","Program","state","walk","body","PackageDeclaration","name","object","ObjectDeclaration","id","superObject","declaration","FeatureDeclaration","init","ObjectName","identifier","ScriptSource","statement","DumpSource","feature","assignments","assignment","script","scripts","FeatureAddition","LabelStatement","FeatureInitialization","value","ScriptDeclaration","part","FunctionDeclaration","param","params","Parameter","IfStatement","consequent","otherClauses","alternate","ElseIfClause","SwitchStatement","discriminant","switchCase","cases","SwitchCase","tests","WhileStatement","RepeatStatement","ForStatement","update","ForEachStatement","left","right","StructuredForStatement","variable","start","end","step","BreakStatement","ContinueStatement","EmptyStatement","BreakIfStatement","ContinueIfStatement","GotoStatement","label","ReturnStatement","argument","VariableDeclaration","declarations","VariableDeclarator","ConditionalExpression","BinaryExpression","UnaryExpression","MemberExpression","property","SliceExpression","IndexExpression","index","CallExpression","callee","arguments","ThisExpression","SuperExpression","AssocExpression","properties","Property","key","ListExpression","element","elements","ListComprehension","expression","AtExpression","ParenthesisExpression","XlateExpression","ospace","string","Identifier","LegacyAlias","Literal","visitors","ancestors","isNew","length","push","callbacks","pre","pop","position","line","column","loc","error","visitor"],"mappings":"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"}